function [clusPos_Z_Stat, clusPval_Z_Stat, clusPval_clusSize, clusPos_clusSize] = ITC_permutation_test(original_ITC, ChDta, ibi_series, numPerms, freq_bins, time_bins, SR)
% INPUTS:
% original_ITC - Original inter-trial coherence values [Freq x Time]
% ibi_series - Vector of interbeat intervals (IBIs) for R-peaks
% numPerms - Number of permutations (e.g., 1000)
% freq_bins, time_bins - The frequency and time bins for analysis

% OUTPUTS:
% p_values - Raw p-values (Freq x Time)

% Initialize storage for permutation-based ITC
permuted_ITCs = zeros([numPerms, size(original_ITC, 1), size(original_ITC, 2)]);

BandWidth=2; % BandWidth in Hz;
Qfac     =2; % Attenuation in db(-Qfac)
tCircMean=0.05;

tWidth   = 1.5;
tOffset  = 0.4;
FltPassDir = 'onepass';


% Pre-generate surrogate R-peaks outside of the parfor loop
time_shifts_all = rand(numPerms, length(ibi_series)) - 0.3; 
surrogate_rpeaks = cumsum(repmat(ibi_series, numPerms, 1), 2) + time_shifts_all;


% Time Lock the surrogate R Peaks to the Channel Data
% [EvData] = time_lock_to_surrogate(ChDta, surrogate_rpeaks, SR, freq_bins, tWidth, tOffset,  BandWidth, Qfac, FltPassDir);


startTime = datetime('now');
disp(['Start Time: ', datestr(startTime)]);

% Generate Permutations
for perm = 1:numPerms
   % % Step 1: Generate surrogate R-peaks
   %  time_shifts = rand(size(ibi_series)) - 0.5; % in sec
   %  surrogate_rpeaks(perm,:) = cumsum(ibi_series) + time_shifts;

    % Time Lock the surrogate R Peaks to the Channel Data
    [EvData] = time_lock_to_surrogate(ChDta, surrogate_rpeaks, SR, freq_bins, tWidth, tOffset,  BandWidth, Qfac, FltPassDir);

    % Step 2: Calculate ITC with the surrogate R-peaks (one per channel)
    [PermItcData(perm, :, :)] = Get_PSI_ByTrials_ITC(EvData,SR,tCircMean);

    fprintf('perm = %d \n', perm)
end

endTime = datetime('now');
disp(['End Time: ', datestr(endTime)]);

% Calculate elapsed time
elapsedTime = endTime - startTime;
disp(['Elapsed Time: ', char(elapsedTime)]);
% Define significance threshold and alpha level
THRESH_SUPRACLUSTER = 0.05; % Threshold for suprathreshold clusters
ALPHA = 0.05; % Alpha level for final significance testing

PermItcData   = permute(PermItcData, [1,3,2]);  % re-order dimensions to: (NUMPERMS x TIME, FREQ)
original_ITC = permute(original_ITC, [2,1]); % re-order dimensions to: (TIME, FREQ)

% Step 1: Compute z-scores
diff_sum_perm_mean = squeeze(mean(PermItcData)); % Mean of the permutation distribution
diff_sum_perm_std = squeeze(std(PermItcData)); % Standard deviation of permutation distribution

diffPerm_mean(1,:,:) = diff_sum_perm_mean;
diffPerm_std(1,:,:)  = diff_sum_perm_std;

zscores = (original_ITC - diff_sum_perm_mean) ./ diff_sum_perm_std ;
zscores_perm = (PermItcData - diffPerm_mean) ./ diffPerm_std;

% Step 2: Compute p-values from z-scores (two-tailed)
p_orig = 2 * (1 - normcdf(zscores, 0, 1)); % no abs bc unidirectional 

% Step 3: Calculate z-scores for permutations
p_perm = 2 * (1 - normcdf(zscores_perm, 0, 1)); % no abs bc unidirectional 

% Step 4: Prepare inputs for getSignifClusters
% Create a logical significance matrix for the original data
p_sig = p_orig < THRESH_SUPRACLUSTER;

% Call getSignifClusters to find clusters
[clusPval_Z_Stat, clusPos_Z_Stat, clusPval_clusSize, clusPos_clusSize] = ...
    getSignifClusters_ITC(p_sig, zscores, p_perm, zscores_perm, THRESH_SUPRACLUSTER, ALPHA);

% The output clusPos_Z_Stat and clusPos_clusSize will indicate positions of significant clusters
% clusPval_Z_Stat and clusPval_clusSize contain p-values for each detected cluster
end


% Function to time-lock neural data (e.g., EEG/LFP) to surrogate R-peaks
function   [EvData] = time_lock_to_surrogate(ChDta, surrogate_rpeaks, SR,  tWidth, tOffset, BandWidth, Qfac, FltPassDir)

dtTime = 1/SR;
%[EventTms,EvData,TmAxis]=GetEvTimeAndData(surrogate_rpeaks,ChDta,dtTime,tWidth,tOffset);
%[EvTime,EvData,TmAxis]=GetEvTimeAndData(MasEvent,MasData,dtTime,tWidth,tOffset,stPlot)

nEvent=length(surrogate_rpeaks);
[frs, nDataAll] = size(ChDta);

nWidth=int32(tWidth/dtTime)+1;
nOffset=int32(tOffset/dtTime)+1;

% define posible namber of Events
for permIdx = 1:nPerms
    % Get the surrogate R-peaks for the current permutation
    currSurrogateRpeaks = surrogate_rpeaks(permIdx, :);
    
    % Find possible events for the current permutation
    MasEnableEvents = int32(zeros(nEvent, 1));
    nPosibleEvent = int32(0);
    
    for i = 1:nEvent
        currTime = int32(currSurrogateRpeaks(i)/dtTime);
        n1 = currTime - nOffset;
        n2 = n1 + nWidth - 1;
        
        if n1 > 0 && n2 < nDataAll
            nPosibleEvent = nPosibleEvent + 1;
            MasEnableEvents(nPosibleEvent) = i;
        end
    end
    
    nEvent = nPosibleEvent;  % Update nEvent to the number of valid events
    
    % Time-lock the data for this permutation
    EvTime = zeros(1, nEvent);
    
    for i = 1:nEvent
        EvTime(i) = currSurrogateRpeaks(MasEnableEvents(i));
        currTime = int32(EvTime(i)/dtTime);
        n1 = currTime - nOffset;
        n2 = n1 + nWidth - 1;
        EvData(permIdx, :, :) = ChDta(:, n1:n2);
    end
end
%[nEvs,nFreqs,nData]=size(EvData);

% Vectorized TmAxis calculation
%TmAxis = (-tOffset:dtTime:(-tOffset + (nWidth - 1) * dtTime))';

%TmAxis=zeros(nData,1);
%s=-1*tOffset;  for i=1:nData;  TmAxis(i)=s;  s=s+dtTime;  end


end


